## اطلاعات اعضای گروه

آرمان محمدی ۹۷۱۰۲۳۸۸

بردیا خدادادی اسکی ۹۸۱۰۶۴۳۴

## الگوی Abstract Factory

برای پیاده‌سازی این الگو باید کلاس‌ها و متدهای لازم را مطابق UML ترسیم‌شده در ویدیوی آموزشی تعریف کنیم. برای این کار ابتدا تست‌‌های برنامه را می‌نویسیم. ابتدا تست مربوط به باغ ایرانی را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 12 15 11 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/83e5b105-16ce-4b15-b3d2-9ed4504749c7">

  ارورهای کامپایلری را مشاهده می‌کنیم، زیرا کلاس‌های ما هنوز ایجاد نشده‌اند. پس پیاده‌سازی را (که در پوشه‌ی `AsbtractFactroy` موجود است) انجام می‌دهیم. با اجرای دوباره‌ی تست انجام‌شده مشاهده می‌کنیم که با موفقیت پاس می‌شود:
  
  <img width="1680" alt="Screenshot 1402-02-21 at 12 22 01 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/a6bb5b81-8372-486d-8d8d-e96037e109f1">

حال، تست مربوط به باغ ژاپنی را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 12 23 25 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/3ac74807-632c-43b8-8f8e-19a731e02244">

دوباره به دلیل عدم پیاده‌سازی ارورهای کامپایلری را مشاهده می‌کنیم که با پیاده‌سازی کلاس‌های مربوطه این تست نیز پاس می‌شود:

<img width="1680" alt="Screenshot 1402-02-21 at 12 24 57 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/d3a4591b-03d5-4729-ac1d-771f83f774e6">

در دو تصویر زیر، پیاده‌سازی دو کلاس  `IranianGardenCreator` و `JapaneseGardenCreator` را مشاهده می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-22 at 3 28 22 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/77e9c43e-4c5b-452a-99e1-97a0793214d9">

<img width="1680" alt="Screenshot 1402-02-22 at 3 28 31 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/187eec86-605b-40ce-87f9-ab60c07d6aa7">

مشاهده می‌کنیم که سازنده‌ی اول تنها مسئولیت ساخت درخت‌ها و گل‌های ایرانی را بر عهده دارد و سازنده‌ی دوم نیز تنها مسئولیت ساخت درخت‌های ژاپنی را بر عهده دارد. پس اگر بخواهیم یک باغ بسازیم،‌ کافی است نوع سازنده‌ی مورد نظر را انتخاب کنیم و به تعداد لازم از گل‌ها و درخت‌های مورد نیاز بسازیم. با این روش اطمینان داریم که در میان یک باغ ژاپنی، درخت یا گل ایرانی نخواهیم داشت و برعکس. یکی دیگر از مزایای استفاده از این الگو این است که اگر بخواهیم یک باغ جدید (مثلا باغ آلمانی) تعریف کنیم، کافی است که یک سازنده که از کلاس `AsbtractGardenCreator` ارث‌بری می‌کند و درخت و گل متناظر با آن را تعریف و پیاده‌سازی کنیم و پیاده‌سازی کلاس‌های از قبل تعریف‌شده بدون تغییر باقی می‌ماند. اما مثلا اگر بخواهیم یک محصول جدید (مثلا بوته) به باغ‌هایمان اضافه کنیم، آنگاه باید علاوه بر افزودن کلاس‌های متناظر با هر نوع باغ و کلاس انتزاعی پدر، یک متد جدید برای ساخت بوته به کلاس `AbstractGardenCreator` و همچنین تمامی کلاس‌های سازنده اضافه کنیم. در نتیجه تمامی کلاس‌های سازنده‌ی ما نیاز به تغییر خواهند داشت که یک عیب این الگو می‌باشد. یک best practice در استفاده از این الگو این می‌باشد که کلاس‌های سازنده را به صورت singleton تعریف کنیم، زیرا در هر برنامه حداکثر به یک نمونه از هر نوع سازنده نیاز خواهیم‌داشت.


## الگوی Prototype

برای پیاده‌سازی این الگو از مثال موجود در سایت
[Refactoring GURU](https://refactoring.guru/design-patterns/prototype/java/example)
استفاده کردیم که پیاده‌سازی دو شکل مستطیل و دایره در جاوا می‌باشد. ابتدا تست‌های مرتبط را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 1 44 37 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/6730ac63-1698-4de2-aaaa-c4761811b3e0">

ارورهای سینتکسی را که به دلیل عدم پیاده‌سازی می‌باشد مشاهده می‌کنیم. البته طبق روش TDD در هر مرحله باید حداکثر یک تست ناموفق داشته‌باشیم اما با توجه به اینکه این روش بیان می‌کند که از آنجایی که این روش می‌تواند بسیار کند باشد و اگر حس می‌کنید می‌توانید فرآیند توسعه را سرعت بخشید، ما دو تست این برنامه را با هم نوشتیم (زیرا سورس کد را ابتدا داشتیم و می‌دانستیم که به مشکل اساسی برنخواهیم خورد). سپس، پیاده‌سازی را انجام می‌دهیم که کد آن در پوشه‌ی `Prototype`وجود دارد. با اضافه‌کردن کد پیاده‌سازی و اجرای دوباره‌ی تست‌ها خواهیم داشت:

<img width="1680" alt="Screenshot 1402-02-21 at 1 45 40 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/1a3e5294-9466-4623-923b-45a2851c13a8">

اگر به تست‌ها دقت کنیم، مشاهده می‌کنیم که اشیای تولیدشده مقادیری برابر با شیء اولیه دارند ولی دو شیء مجزا می‌باشند (‍‍‍`AssertNotSame`). از مزایای این الگو این است که ما وارد جزئیات پیاده‌سازی کلاس‌ها نشده‌ایم و تنها با صدازدن متد `clone` یک کپی از شیء مورد نظر تولید کردیم. همچنین در مواقعی که برخی از فیلدهای کلاس private باشند، امکان کپی مستقیم یک شیء وجود ندارد که این در حالت نیز استفاده از این الگو می‌تواند بسیار کابردی باشد. فقط در پیاده‌سازی این الگو باید دقت کنیم هنگامی که یک ارجاع دوری بین چند شیء وجود دارد، باید پیاده‌سازی با دقت انجام شود. زیرا مثلا اگر بخواهیم در عملیات کلون کردن تنها تابع `clone` اشیا‌ي دیگر را صدا بزنیم، چون یک ارجاع دوری وجود دارد پس در لوپ بی‌نهایت خواهیم افتاد و برنامه‌ی ما هیچ گاه پایان نمی‌یابد. از طرفی اگر بخواهیم در هنگامی که یک ارجاع داریم همان شیء مرجوع را به عنوان یک attribute در شیء جدید تعریف کنیم، ممکن است در برنامه به ارورهای منطقی برخورد کنیم. پس باید با توحه به منطق برنامه و نیازمندی‌ها عملیات کلون‌کردن را به درستی برای هر کلاس تعریف کنیم.


## الگوی Builder

برای پیاده‌سازی این الگو از مثال موجود در سایت
[Refactoring GURU](https://refactoring.guru/design-patterns/builder/java/example)
استفاده کردیم که یک کارخانه‌ی تولید وسیله نقلیه می‌باشد. در این کارخانه ما دو نوع وسیله نقلیه داریم. ماشین(`Car`) و دستی(`Manual`). توجه شود که این دو وسیله‌ی نقلیه کاملا مستقل از یکدگیر می‌باشند. ابتدا تست مربوط به ماشین را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 2 31 29 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/8600788e-dfa8-4096-a3b9-9b16203caf08">

به ارورهای کامپایلری برمی‌خوریم. برای رفع این ارورها کلاس‌های لازم را پیاده‌سازی می‌کنیم و تست‌ها را دوباره اجرا می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-21 at 2 31 52 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/c93a923f-05a8-4b87-bb3b-29d7c720a3dd">
 
 مشاهده می‌کنیم که تست مورد نظر با موفقیت پاس می‌شود. حال تست مربوط به دستی را می‌نویسیم:
 
 <img width="1680" alt="Screenshot 1402-02-21 at 2 41 38 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/fe9ab69f-6ead-49fb-a0b3-f2202022237f">

به ارورهای کامپایلری برمی‌خوریم و برای رفع این ارورها کلاس‌های `Manual` و `CarManualBuilder` را پیاده‌سازی می‌کنیم و تست‌ها را دوباره اجرا می‌کنیم

<img width="1680" alt="Screenshot 1402-02-21 at 2 41 54 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/6a774799-cf24-4b8b-9f86-0fcb5a65d305">

مشاهده می‌کنیم که تست‌ها با موفقیت پاس می‌شوند. در این مثال، ماشین و دستی از قطعات مختلفی تشکیل شده‌اند و بسیاری از این قطعات بین این دو کلاس مشترک می‌باشند، پس منطقی است که از الگوی builder استفاده کنیم. با این کار یکپارچگی برنامه حفظ می‌شود و از نوشتن کد تکراری و مشکلات ناشی از آن جلوگیری می‌شود. در این مثال دو نوع وسیله‌ی نقلیه وجود دارد که هر کدوم ۳ نوع متفاوت دارند. اگر می‌خواستیم کلاس‌های آنها را به صورت مجزا پیاده‌سازی کنیم نیاز به تعریف ۶ کلاس مجزا داشتیم. اگر در آینده وسیله‌ی نقلیه‌ی جدیدی تعریف می‌شد، آنگاه باید کلاس‌های جدید بیشتری تعریف می‌کردیم و اگر نیاز به تعریف دسته‌بندی‌های جدیدی داشتیم تعداد کلاس‌ها به طور نمایی افزایش می‌یافت، اما با استفاده از این الگو و با حفظ اصل SRP، پایداری و manitainability کد به شدت افزایش می‌یابد.



## پرسش‌ها

### پرسش اول

الگوهای تعریف شده در این کتاب شامل الگوهای ایجادی(Creational)، ساختاری(Structural) و رفتاری(Behavioral) می‌باشند. 

**الگوهای ایجادی:**
این الگوها به مکانیزم‌های ایجاد شیء می‌پردازند. این الگوها روش‌هایی را ارائه می‌دهند که طراحان نرم‌افزار کمک می‌کند تا اشیا را به گونه‌ای ایجاد کنند که flexibility، decopuling و reusability حفظ شود. این الگوها در طراحی نرم‌افزار برای مدیریت فرآیند ایجاد شیء و ایجاد ارتباطات بین آن‌ها بسیار کارآمد هستند. این الگوها به طراحان امکان می‌دهند تا از جزئیات پیچیده ساختار شیء خود خبر نداشته باشند. همچنین این الگوها سطح بالایی از انتزاع را فراهم می‌کنند که اجازه می‌دهد تا ساختارهای پیچیده را به راحتی مدیریت کنند.

**الگوهای ساختاری:**
الگوهای ساختاری (Structural Patterns) در طراحی نرم‌افزار برای سازماندهی و ارتباط بین شیء‌ها مورد استفاده قرار می‌گیرند. این الگوها اجازه می‌دهند تا رابطه و تعامل بین اجزای سیستم را بهبود بخشیده و بهبود قابلیت گسترش، انعطاف‌پذیری و قابلیت استفاده مجدد را فراهم کنند. برخی از الگوهای ساختاری عبارتند از Adapter، Bridge، Composite، Decorator، و Facade.

**الگوهای رفتاری:**
الگوهای رفتاری (Behavioral Patterns) در طراحی نرم‌افزار برای مدیریت رفتار و تعامل بین اجزای سیستم استفاده می‌شوند. این الگوها به طراحان نرم‌افزار کمک می‌کنند تا روابط و الگوهای ارتباطی میان شیء‌ها را تعریف کرده و تغییرات رفتار را با حداقل تغییر در کدها اعمال کنند.


### پرسش دوم
الگوهای استفاده‌شده در این آزمایش از نوع ایجادی(Creational) می‌باشند.

 ### پرسش سوم
فرق اصول SOLID و الگوهای GoF در درشت‌دانگی و ریزدانگی آنهاست. SOLID اصولی کلی را بیان می‌کند و به برنامه‌نویسان توصیه می‌کند که آنها را در تمامی کدهای خود رعایت کنند،‌ اما الگوهای GoF مربوط به یک شرایط خاص، یک مسئله و یک مشکل خاص می‌باشد و راه‌حل و الگوی ارائه‌شده تنها در آن context و مشکل کاربرد دارد. 

### پرسش چهارم
الگوی Singleton به دلیل وجود یک نمونه یکتا از یک کلاس، از اصل SRP (Single Responsibility Principle) در اصول SOLID خارج می‌شود. اصل SRP بیان می‌کند که یک کلاس باید فقط یک مسئولیت مشخص را داشته باشد. اما در الگوی Singleton، کلاس علاوه بر مسئولیت اصلی خود، همچنین مسئولیت ایجاد و مدیریت نمونه خود را نیز برعهده دارد. این موجب ترکیب دو مسئولیت مختلف در یک کلاس می‌شود و باعث نقض اصل SRP می‌گردد.
