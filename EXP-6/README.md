## الگوی Abstract Factory

برای پیاده‌سازی این الگو باید کلاس‌ها و متدهای لازم را مطابق UML ترسیم‌شده در ویدیوی آموزشی تعریف کنیم. برای این کار ابتدا تست‌‌های برنامه را می‌نویسیم. ابتدا تست مربوط به باغ ایرانی را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 12 15 11 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/83e5b105-16ce-4b15-b3d2-9ed4504749c7">

  ارورهای کامپایلری را مشاهده می‌کنیم، زیرا کلاس‌های ما هنوز ایجاد نشده‌اند. پس پیاده‌سازی را (که در پوشه‌ی `AsbtractFactroy` موجود است) انجام می‌دهیم. با اجرای دوباره‌ی تست انجام‌شده مشاهده می‌کنیم که با موفقیت پاس می‌شود:
  
  <img width="1680" alt="Screenshot 1402-02-21 at 12 22 01 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/a6bb5b81-8372-486d-8d8d-e96037e109f1">

حال، تست مربوط به باغ ژاپنی را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 12 23 25 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/3ac74807-632c-43b8-8f8e-19a731e02244">

دوباره به دلیل عدم پیاده‌سازی ارورهای کامپایلری را مشاهده می‌کنیم که با پیاده‌سازی کلاس‌های مربوطه این تست نیز پاس می‌شود:

<img width="1680" alt="Screenshot 1402-02-21 at 12 24 57 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/d3a4591b-03d5-4729-ac1d-771f83f774e6">

در دو تصویر زیر، پیاده‌سازی دو کلاس  `IranianGardenCreator` و `JapaneseGardenCreator` را مشاهده می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-22 at 3 28 22 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/77e9c43e-4c5b-452a-99e1-97a0793214d9">

<img width="1680" alt="Screenshot 1402-02-22 at 3 28 31 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/187eec86-605b-40ce-87f9-ab60c07d6aa7">

مشاهده می‌کنیم که سازنده‌ی اول تنها مسئولیت ساخت درخت‌ها و گل‌های ایرانی را بر عهده دارد و سازنده‌ی دوم نیز تنها مسئولیت ساخت درخت‌های ژاپنی را بر عهده دارد. پس اگر بخواهیم یک باغ بسازیم،‌ کافی است نوع سازنده‌ی مورد نظر را انتخاب کنیم و به تعداد لازم از گل‌ها و درخت‌های مورد نیاز بسازیم. با این روش اطمینان داریم که در میان یک باغ ژاپنی، درخت یا گل ایرانی نخواهیم داشت و برعکس. یکی دیگر از مزایای استفاده از این الگو این است که اگر بخواهیم یک باغ جدید (مثلا باغ آلمانی) تعریف کنیم، کافی است که یک سازنده که از کلاس `AsbtractGardenCreator` ارث‌بری می‌کند و درخت و گل متناظر با آن را تعریف و پیاده‌سازی کنیم و پیاده‌سازی کلاس‌های از قبل تعریف‌شده بدون تغییر باقی می‌ماند. اما مثلا اگر بخواهیم یک محصول جدید (مثلا بوته) به باغ‌هایمان اضافه کنیم، آنگاه باید علاوه بر افزودن کلاس‌های متناظر با هر نوع باغ و کلاس انتزاعی پدر، یک متد جدید برای ساخت بوته به کلاس `AbstractGardenCreator` و همچنین تمامی کلاس‌های سازنده اضافه کنیم. در نتیجه تمامی کلاس‌های سازنده‌ی ما نیاز به تغییر خواهند داشت که یک عیب این الگو می‌باشد. یک best practice در استفاده از این الگو این می‌باشد که کلاس‌های سازنده را به صورت singleton تعریف کنیم، زیرا در هر برنامه حداکثر به یک نمونه از هر نوع سازنده نیاز خواهیم‌داشت.
