## اطلاعات اعضای گروه

آرمان محمدی ۹۷۱۰۲۳۸۸
بردیا خدادادی اسکی ۹۸۱۰۶۴۳۴

## الگوی Abstract Factory

برای پیاده‌سازی این الگو باید کلاس‌ها و متدهای لازم را مطابق UML ترسیم‌شده در ویدیوی آموزشی تعریف کنیم. برای این کار ابتدا تست‌‌های برنامه را می‌نویسیم. ابتدا تست مربوط به باغ ایرانی را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 12 15 11 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/83e5b105-16ce-4b15-b3d2-9ed4504749c7">

  ارورهای کامپایلری را مشاهده می‌کنیم، زیرا کلاس‌های ما هنوز ایجاد نشده‌اند. پس پیاده‌سازی را (که در پوشه‌ی `AsbtractFactroy` موجود است) انجام می‌دهیم. با اجرای دوباره‌ی تست انجام‌شده مشاهده می‌کنیم که با موفقیت پاس می‌شود:
  
  <img width="1680" alt="Screenshot 1402-02-21 at 12 22 01 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/a6bb5b81-8372-486d-8d8d-e96037e109f1">

حال، تست مربوط به باغ ژاپنی را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 12 23 25 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/3ac74807-632c-43b8-8f8e-19a731e02244">

دوباره به دلیل عدم پیاده‌سازی ارورهای کامپایلری را مشاهده می‌کنیم که با پیاده‌سازی کلاس‌های مربوطه این تست نیز پاس می‌شود:

<img width="1680" alt="Screenshot 1402-02-21 at 12 24 57 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/d3a4591b-03d5-4729-ac1d-771f83f774e6">

در دو تصویر زیر، پیاده‌سازی دو کلاس  `IranianGardenCreator` و `JapaneseGardenCreator` را مشاهده می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-22 at 3 28 22 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/77e9c43e-4c5b-452a-99e1-97a0793214d9">

<img width="1680" alt="Screenshot 1402-02-22 at 3 28 31 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/187eec86-605b-40ce-87f9-ab60c07d6aa7">

مشاهده می‌کنیم که سازنده‌ی اول تنها مسئولیت ساخت درخت‌ها و گل‌های ایرانی را بر عهده دارد و سازنده‌ی دوم نیز تنها مسئولیت ساخت درخت‌های ژاپنی را بر عهده دارد. پس اگر بخواهیم یک باغ بسازیم،‌ کافی است نوع سازنده‌ی مورد نظر را انتخاب کنیم و به تعداد لازم از گل‌ها و درخت‌های مورد نیاز بسازیم. با این روش اطمینان داریم که در میان یک باغ ژاپنی، درخت یا گل ایرانی نخواهیم داشت و برعکس. یکی دیگر از مزایای استفاده از این الگو این است که اگر بخواهیم یک باغ جدید (مثلا باغ آلمانی) تعریف کنیم، کافی است که یک سازنده که از کلاس `AsbtractGardenCreator` ارث‌بری می‌کند و درخت و گل متناظر با آن را تعریف و پیاده‌سازی کنیم و پیاده‌سازی کلاس‌های از قبل تعریف‌شده بدون تغییر باقی می‌ماند. اما مثلا اگر بخواهیم یک محصول جدید (مثلا بوته) به باغ‌هایمان اضافه کنیم، آنگاه باید علاوه بر افزودن کلاس‌های متناظر با هر نوع باغ و کلاس انتزاعی پدر، یک متد جدید برای ساخت بوته به کلاس `AbstractGardenCreator` و همچنین تمامی کلاس‌های سازنده اضافه کنیم. در نتیجه تمامی کلاس‌های سازنده‌ی ما نیاز به تغییر خواهند داشت که یک عیب این الگو می‌باشد. یک best practice در استفاده از این الگو این می‌باشد که کلاس‌های سازنده را به صورت singleton تعریف کنیم، زیرا در هر برنامه حداکثر به یک نمونه از هر نوع سازنده نیاز خواهیم‌داشت.


## الگوی Prototype

برای پیاده‌سازی این الگو از مثال موجود در سایت
[Refactoring GURU](https://refactoring.guru/design-patterns/prototype/java/example)
استفاده کردیم که پیاده‌سازی دو شکل مستطیل و دایره در جاوا می‌باشد. ابتدا تست‌های مرتبط را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-21 at 1 44 37 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/6730ac63-1698-4de2-aaaa-c4761811b3e0">

ارورهای سینتکسی را که به دلیل عدم پیاده‌سازی می‌باشد مشاهده می‌کنیم. البته طبق روش TDD در هر مرحله باید حداکثر یک تست ناموفق داشته‌باشیم اما با توجه به اینکه این روش بیان می‌کند که از آنجایی که این روش می‌تواند بسیار کند باشد و اگر حس می‌کنید می‌توانید فرآیند توسعه را سرعت بخشید، ما دو تست این برنامه را با هم نوشتیم (زیرا سورس کد را ابتدا داشتیم و می‌دانستیم که به مشکل اساسی برنخواهیم خورد). سپس، پیاده‌سازی را انجام می‌دهیم که کد آن در پوشه‌ی `Prototype`وجود دارد. با اضافه‌کردن کد پیاده‌سازی و اجرای دوباره‌ی تست‌ها خواهیم داشت:

<img width="1680" alt="Screenshot 1402-02-21 at 1 45 40 PM" src="https://github.com/arplusman/software-engineering-lab/assets/45389988/1a3e5294-9466-4623-923b-45a2851c13a8">

اگر به تست‌ها دقت کنیم، مشاهده می‌کنیم که اشیای تولیدشده مقادیری برابر با شیء اولیه دارند ولی دو شیء مجزا می‌باشند (‍‍‍`AssertNotSame`). از مزایای این الگو این است که ما وارد جزئیات پیاده‌سازی کلاس‌ها نشده‌ایم و تنها با صدازدن متد `clone` یک کپی از شیء مورد نظر تولید کردیم. همچنین در مواقعی که برخی از فیلدهای کلاس private باشند، امکان کپی مستقیم یک شیء وجود ندارد که این در حالت نیز استفاده از این الگو می‌تواند بسیار کابردی باشد. فقط در پیاده‌سازی این الگو باید دقت کنیم هنگامی که یک ارجاع دوری بین چند شیء وجود دارد، باید پیاده‌سازی با دقت انجام شود. زیرا مثلا اگر بخواهیم در عملیات کلون کردن تنها تابع `clone` اشیا‌ي دیگر را صدا بزنیم، چون یک ارجاع دوری وجود دارد پس در لوپ بی‌نهایت خواهیم افتاد و برنامه‌ی ما هیچ گاه پایان نمی‌یابد. از طرفی اگر بخواهیم در هنگامی که یک ارجاع داریم همان شیء مرجوع را به عنوان یک attribute در شیء جدید تعریف کنیم، ممکن است در برنامه به ارورهای منطقی برخورد کنیم. پس باید با توحه به منطق برنامه و نیازمندی‌ها عملیات کلون‌کردن را به درستی برای هر کلاس تعریف کنیم.


