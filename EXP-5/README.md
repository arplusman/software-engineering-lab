# کزارش آزمایش


ابتدا تست مربوط به مستطیل را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-15 at 11 49 22 PM" src="https://user-images.githubusercontent.com/45389988/236565670-d78573b6-33f3-4334-aefb-43b56658fd11.png">

با اجرای تست مشاهده می‌کنیم که نمی‌تواند کلاس مربوطه را پیدا کند:

<img width="1680" alt="Screenshot 1402-02-15 at 11 49 32 PM" src="https://user-images.githubusercontent.com/45389988/236565795-18114fb6-486f-477f-99c7-d18a4d318412.png">

پس، کلاس `Rectangle` را پیاده‌سازی می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-15 at 11 53 13 PM" src="https://user-images.githubusercontent.com/45389988/236565881-c55adf32-10b0-407a-b07c-047e98b63f54.png">

دوباره تست را اجرا می‌کنیم و این بار با ارور زمان اجرا مواجه می‌شویم:

<img width="1680" alt="Screenshot 1402-02-15 at 11 53 13 PM" src="https://user-images.githubusercontent.com/45389988/236566075-cfb9bc6b-5773-473c-a6db-03562c505b0b.png">

اشکالات موجود در کد را برطرف می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-15 at 11 53 18 PM" src="https://user-images.githubusercontent.com/45389988/236566106-0043c924-a3b0-4f9a-a769-3006589bb068.png">

دوباره تست‌ها را اجرا می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-15 at 11 53 32 PM" src="https://user-images.githubusercontent.com/45389988/236566150-15820944-43fd-4d30-901a-7d9e32d3e598.png">

مشاهده می‌کنیم که تست مورد نظر پاس شده‌است. حال، تست مربوط به متدهای `get` و `set` را می‌نویسیم و با اجرای آن با خطاهای کامپایلری زیر مواجه می‌شویم:

<img width="1680" alt="Screenshot 1402-02-15 at 11 59 40 PM" src="https://user-images.githubusercontent.com/45389988/236566289-56a14372-bf4f-461a-bc5b-800e09025131.png">

متدهای مورد نظر را پیاده‌سازی می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-15 at 11 59 46 PM" src="https://user-images.githubusercontent.com/45389988/236566462-426477d1-37b3-47cf-899f-9faf9537d534.png">

تست‌ها را دوباره اجرا می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-16 at 12 00 03 AM" src="https://user-images.githubusercontent.com/45389988/236566631-e793f4b6-9bd3-4fa6-83e8-b8c14e033a48.png">

برای این کار ابتدا اینترفیس `Shape` را تعریف می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-16 at 12 01 57 AM" src="https://user-images.githubusercontent.com/45389988/236566743-f3a8fe75-5f38-48d3-9534-1b8754b64be5.png">

سپس کلاس `Shape` را از این اینترفیس ارث‌بری می‌کنیم:


<img width="1680" alt="Screenshot 1402-02-16 at 12 02 17 AM" src="https://user-images.githubusercontent.com/45389988/236566882-1968c37f-6ead-4876-bb23-a176abbc61e1.png">

حال، تست‌های مربوط به کلاس `Square` را می‌نویسیم:

<img width="1680" alt="Screenshot 1402-02-16 at 12 11 07 AM" src="https://user-images.githubusercontent.com/45389988/236566990-94a6d9b0-9edf-4f10-90f2-fc19049bd48d.png">

ارورهای زمان کامپایل را مشاهده می‌کنیم. پس پیاده‌سازی این کلاس را انجام می‌دهیم:

<img width="1680" alt="Screenshot 1402-02-16 at 12 11 16 AM" src="https://user-images.githubusercontent.com/45389988/236567119-732bcffd-cafd-436c-a0f2-03025775c596.png">

با اجرای تست‌ها ارورهای زمان اجرا را مشاهده می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-16 at 12 11 25 AM" src="https://user-images.githubusercontent.com/45389988/236567217-62d57e84-1611-4e06-bee6-d9953574ad72.png">

با تغییر منطق برنامه، اشکالات موجود را برطرف می‌کنیم:

<img width="1680" alt="Screenshot 1402-02-16 at 12 11 41 AM" src="https://user-images.githubusercontent.com/45389988/236567277-e6a9b657-d2ea-4f59-acff-a89d57d276d8.png">

مشاهده می‌کنیم که تمامی تست‌ها با موفقیت پاس شده‌اند.

# پرسش‌ها

## سوال اول
### اصل اول: Single responsibility principle

این اصل به این معنا نیست که کلاس باید یک کار انجام بدهد، بلکه به این معناست که کلاس باید فقط یک دلیل برای تغییر داشته باشد. در واقع یعنی یک کلاس باید فقط و فقط به یک actor پاسخگو باشد. یعنی حتی اگر کلاس چندین کار هم انجام داد، این باید فقط و فقط در راستای پاسخگویی به یک actor باشد.

### اصل دوم: Open/closed principle

یعنی کلاسی که مینویسیم باید برای گسترش دادنش باز باشد، اما برای تغییر دادنش بسته باشد. به این معنی که بتوان به راحتی یک قابلیت جدید به کلاس اضافه کرد، بدون آن که مجبور باشیم کد کلاس را تغییر دهیم. یکی از راه های براورده کردن این اصل، رعایت اصل DIP است که اصل آخر است.

### اصل سوم: Liskov substitution principle

این اصل به این معنا است که کلاس فرزند باید بتواند جایگزین کلاس والد باشد. میدانیم هر کلاسی یک سری pre-condition و یک سری post-condition دارد. این اصل به آن معناست که هر متدی که در کلاس فرزند است و آن را از کلاس والد به ارث برده است، نباید pre-condition قوی تری داشته باشد و همچنین نباید post-condition ضعیف تری داشته باشد.

### اصل چهارم: Interface segregation principle

این اصل به این معنی است که یک واسط general خیلی بدتر از چند واسط cohesive است. در واقع بهتر است که یک وایط چندین کار را انجام ندهد.

### اصل پنجم: Dependency inversion principle

فرض کنید یک کلاس A و یک کلاس B داریم که بین آنها رابطه association برقرار است، یعنی یک فیلدی از B در A استفاده میشود. این اصل میگوید که بتر است کلاس B کلاسی abstract باشد و concrete نباشد. در واقع کلاس A به به specification وابسته باشد و نه به پیاده سازی کلاس B.


## سوال دوم

 تعداد زیادی اصول برای مرحله طراحی نرم افزار ها وجود دارد که یکی از آن ها اصول SOLID است.این اصول به این منظور طراحی شده اند که معماری یک برنامه کاربردی را انعطاف پذیرتر، مقیاس پذیرتر و قابل نگهداری تر کنند. اجرای آنها در کار شما می تواند پیچیدگی کلی پروژه را نیز افزایش دهد.

## سوال سوم

هسته TDD نوشتن تست قبل از هر کد تولید است. این اساساً با نحوه انجام کارها در تضاد است. ما می خواهیم کار را سریع به پایان برسانیم و فقط آنچه را که ارسال می شود بنویسیم. ما کد آزمایشی را ارسال نمی کنیم، بنابراین می خواهیم فقط کد نهایی را بنویسیم و با آن کار تمام شود.

تست‌های نوشتاری، توسعه‌دهنده را مجبور می‌کند تا قبل از کدنویسی، یک بار دیگر به تمام الزامات فکر کند، که این چیز خوبی است. اغلب به حذف برخی از فرضیات نامربوط که توسعه‌دهنده ناخودآگاه مطرح کرده‌اند کمک می‌کند. ترجمه الزامات متن به کد اغلب موارد حاشیه ای را نشان می‌دهد که تیم محصول قبلاً به آنها فکر نکرده بود. با این حال، این کار اضافی از . فکر کردن، هنوز هم کار بیشتری بر دوش توسعه دهنده است.

بدون شک TDD سخت است، اما مزایای زیادی دارد. این به ما کمک می کند تا روی نیازمندی ها تمرکز بهتری داشته باشیم، با اطمینان اصلاح کنیم، کد را برای داشتن مسئولیت واحد و رابط های بهتر اجرا کنیم.

## سوال چهارم

در صورتی که نیاز به تغیر ابعاد مستطیل ها نداشته باشیم، می توانیم تابع های setter را از کلاس مان حذف کنیم. در این صورت ابعاد مستطیل فقط در هنگام ساخت object آن داده می شود و پس از آن قابلیت تغییر ندارد. علاوه بر این در شرایطی که ابعاد مستطیل تغییری نکند، مساحت آن نیز تغییر نمی کند. پس می توانیم در تابع constructor درجا مقدار مساخت مستطیل را حساب کرده و به عنوان یک attribute ذخیره کنیم تا هر بار فرایند کال شدن تابع و محاسبه مقدار صورت نگیرد.

